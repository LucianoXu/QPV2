// A sorting of qubits a, b and c

// predicate "less or equal"
Def le := P0 ⊗ P0 ∨ P0 ⊗ P1 ∨ P1 ⊗ P1.
Def le' := P0 ⊗ P0 + P0 ⊗ P1 + P1 ⊗ P1.

Test le = le'.  // le = le' holds indeed

Def CSWAP := P0 ⊗ I ⊗ I + P1 ⊗ SWAP.

Refine sort3 : < c1[], le[a b] ∧ le[b c] ∧ le[a c] >.

    Step < c1[], le[a b] ∧ le[b c] >.

    Step Seq le[a b] ∧ le [a c].

    Step Seq le[b c].

    Step [t]:=0; CX[b t]; CSWAP[t b c].
    Step [t]:=0; CX[a t]; CSWAP[t a b].
    Step [t]:=0; CX[b t]; CSWAP[t b c].

End.

// quantum teleportation from a to y
Def Peq := P0 ⊗ P0 ∨ P1 ⊗ P1.

Refine teleportation : < Omega[a t] ⊗ Bell00[x y] , Omega[y t] >.
    Step
        CX[a x];
        H[a];
        if P1[x] then X[y] else skip end;
        if P1[a] then Z[y] else skip end.
End.


Show Def.

// Computing operators

Def II := I \otimes I.

Test CX[p q] * CX[q p] * CX[p q] = SWAP[p q].

Test P0 \otimes P1 <= II.

Test P0[p] \vee Pp[q] = I[p].


// Subprograms and proofs.

Def prog := Prog X[x].
Show prog.

Refine pfsub : < P0[x], P1[x] >.

    Step proc prog.

End.
Show pfsub.

Def rho1 := [[proc pfsub]](P0[x]).
Show rho1.




// The example in the draft.
Def P00 := P0 \otimes P0.
Def Pnot00 := (I \otimes I - P00).

Def pCircuit := Prog
    H[q0]; H[q1];
    CCX[q0 q1 t]; S[t]; CCX[q0 q1 t];
    H[q0]; H[q1];
    if Pnot00[q0 q1] then Z[t] else skip end.

Refine pf : < Omega[t t'], Rz[t] * Omega[t t'] * Rz[t]^\dagger >.


    Step Seq Pnot00[q0 q1] * Omega[t t'].
    
    Step [q0 q1] :=0; X[q0].

    Def Inv0 := (Pnot00[q0 q1] \otimes Omega[t t']) \vee (P00[q0 q1] \otimes (Rz[t] * Omega[t t'] * Rz[t]^\dagger)).

    Step While Pnot00[q0 q1] Inv IQOPT Inv0.

    Step Seq P00[q0 q1] \otimes Omega[t t'].
    
    Step [q0 q1] :=0.

    Step proc pCircuit.
End.
Show pf.
Def S0:= Extract pf. Show S0.
Def rho := [[proc S0]](Pp[t]). Show rho.
