// Computing operators

Def II := I \otimes I.
Eval II.
Test CX[p q] CX[q p] CX[p q] = SWAP[p q].
Test P0 \otimes P1 <= II.
Test P0[p] \vee P1[p] = I[p].


// Subprograms and proofs.

Def prog := Prog X[x].
Show prog.

Refine pfsub : [pre : P0[x], post: P1[x]].

    Step Prog prog.

End.



// The example in the draft.

Def Inv := ((I \otimes I - P00)[q0 q1] \otimes Omega[t t']) \vee (P00[q0 q1] \otimes (Rztheta[t] Omega[t t'] Rztheta[t]^\dagger)).

Eval Inv.

Refine pf : [pre : Omega[t t'], post: Rztheta[t] Omega[t t'] Rztheta[t]^\dagger].

    Step 
        [pre : Omega[t t'], post: (I \otimes I - P00)[q0 q1] \otimes Omega[t t']];[pre : (I \otimes I - P00)[q0 q1] \otimes Omega[t t'], post: Rztheta[t] Omega[t t'] Rztheta[t]^\dagger].

    Step 
        [q0 q1] :=0; X[q0].

    

    Step 
        [pre: IQOPT Inv, post: P00[q0 q1] \SasakiConjunct IQOPT Inv].

    Step 
        while (I \otimes I - P00)[q0 q1] do
            [pre: (I \otimes I - P00)[q0 q1] \otimes Omega[t t'], post: IQOPT Inv]
        end.

    Step 
        [q0 q1] :=0; [pre: P00[q0 q1] \otimes Omega[t t'], post: IQOPT Inv].

    Step 
        H[q0]; H[q1];[pre: Pp[q0] \otimes Pp[q1] \otimes Omega[t t'], post: IQOPT Inv].

    Step
        CCX[q0 q1 t]; S[t]; CCX[q0 q1 t];
        // problem?
        H[q0]; H[q1];
        if (I \otimes I - P00)[q0 q1] then
            Z[t]
        else
            skip
        end.
End.

Def pfextract := Extract pf.
Show pfextract.